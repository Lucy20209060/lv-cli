<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Lucy"><title>ES9新特性 · 长剑腥腥挂壁</title><meta name="description" content="ES2018 是 ECMAScript 标准的最新版本
新增一下新特性：

Rest/Spread属性
Asynchronous iteration （异步迭代）
Promise.prototype.finally()
正则表达式改进

Rest/Spread 属性ES2015引入了Rest参数和扩"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/logo-2.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo-2.png" style="width:127px;"><h3 title=""><a href="/">长剑腥腥挂壁</a></h3></div></div><ul class="social-links"></ul></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/logo-2.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>ES9新特性</a></h3></div><div class="post-content"><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">ES2018 是 ECMAScript 标准的最新版本</span></span></p>
<p>新增一下新特性：</p>
<ul>
<li>Rest/Spread属性</li>
<li>Asynchronous iteration （异步迭代）</li>
<li>Promise.prototype.finally()</li>
<li>正则表达式改进</li>
</ul>
<h3 id="Rest-Spread-属性"><a href="#Rest-Spread-属性" class="headerlink" title="Rest/Spread 属性"></a>Rest/Spread 属性</h3><p>ES2015引入了Rest参数和扩展运算符。三个点（…）仅用于数组。</p>
<p>Rest参数语法允许我们将一个布丁数量的参数表示为一个数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, ...z</span>)</span>&#123;</span><br><span class="line">    x <span class="comment">// 1</span></span><br><span class="line">    y <span class="comment">// 2</span></span><br><span class="line">    z <span class="comment">// [3, 4, 5]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure></p>
<p>spread运算符以相反的方式工作，并将数组转换为可以传递给函数的单独参数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(...arr) <span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure></p>
<p>ES2018为对象解构提供了和数组一样的Rest参数和展开操作符<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;a, d, ...y&#125; = &#123;</span><br><span class="line">  a: <span class="string">'A'</span>,</span><br><span class="line">  b: <span class="string">'B'</span>,</span><br><span class="line">  c: <span class="string">'C'</span>,</span><br><span class="line">  d: <span class="string">'D'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// A</span></span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// D</span></span><br><span class="line"><span class="built_in">console</span>.log(y); <span class="comment">// &#123;b:'B', c: 'C'&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>扩展运算符在其他对象内使用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = &#123;</span><br><span class="line">    a: <span class="string">'A'</span>,</span><br><span class="line">    b: <span class="string">'B'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> y = &#123;...x, <span class="attr">c</span>:<span class="string">'C'</span>&#125; <span class="comment">// &#123;a: 'A', b: 'B', c: 'C'&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Asynchronous-iteration-（异步迭代）"><a href="#Asynchronous-iteration-（异步迭代）" class="headerlink" title="Asynchronous iteration （异步迭代）"></a>Asynchronous iteration （异步迭代）</h3><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">新的 </span></span><code>for-await-of</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>构造允许使用异步可迭代对象作为循环迭代<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> line <span class="keyword">of</span> readLines(filePath)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(line)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">由于这使用 </span></span><code>await</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>，你只能在异步函数中使用它，就像普通的 <code>await</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>一样（参见 async / await 章节）</p>
<h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p>当一个 promise 得到满足（fulfilled）时，它会一个接一个地调用 then() 方法<br>如果在此期间发生错误，则跳过 then() 方法并执行 catch()方法<br>finally() 允许您运行一些代码，无论 promise 的执行成功或失败<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'file.json'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> data.json()) <span class="comment">// 成功后调用</span></span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error)) <span class="comment">// 失败后调用</span></span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'finished'</span>)) <span class="comment">// 完成后调用 无论成功失败</span></span><br></pre></td></tr></table></figure></p>
<h3 id="正则表达式改进"><a href="#正则表达式改进" class="headerlink" title="正则表达式改进"></a>正则表达式改进</h3><h4 id="先行断言-lookahead-和-后行断言-lookbehind"><a href="#先行断言-lookahead-和-后行断言-lookbehind" class="headerlink" title="先行断言(lookahead) 和 后行断言(lookbehind)"></a>先行断言(lookahead) 和 后行断言(lookbehind)</h4><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">先行断言(lookahead)</span></span><br><code>?=</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>匹配一个字符串，该字符串后面跟着一个特定的子字符串<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测字符串component后面是否跟随Will字符串</span></span><br><span class="line">/component(?= Will)/.test(<span class="string">'This lifecycle was previously named component WillMount'</span>) <span class="comment">// true</span></span><br><span class="line">/component(?=Will)/.test(<span class="string">'This lifecycle was previously named componentWillMount'</span>) <span class="comment">// true</span></span><br><span class="line">/component(?=Mount)/.test(<span class="string">'This lifecycle was previously named component WillMount'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p><code>?!</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>执行逆操作，匹配一个字符串，该字符串后面没有一个特定的子字符串<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/component(?!Will)/.test(<span class="string">'This lifecycle was previously named componentWillMount'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">后行断言(lookbehind)：根据前面的内容匹配字符串</span></span><br><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">使用 </span></span><code>?&lt;=</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测 Will前面是否是component字符串</span></span><br><span class="line">/(?<span class="xml"><span class="tag">&lt;<span class="name">=component)</span> <span class="attr">Will</span>/<span class="attr">.test</span>('<span class="attr">componentWillMount</span>') //<span class="attr">false</span></span></span></span><br><span class="line"><span class="xml">/(?<span class="tag">&lt;<span class="name">=component)Will</span>/<span class="attr">.test</span>('<span class="attr">componentWillMount</span>') //<span class="attr">true</span></span></span></span><br></pre></td></tr></table></figure></p>
<p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">使用 </span></span><code>?&lt;!</code>，<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">逆操作</span></span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?<span class="xml"><span class="tag">&lt;<span class="name">!component)</span> <span class="attr">Will</span>/<span class="attr">.test</span>('<span class="attr">componentWillMount</span>') //<span class="attr">true</span></span></span></span><br><span class="line"><span class="xml">/(?<span class="tag">&lt;<span class="name">!component)Will</span>/<span class="attr">.test</span>('<span class="attr">componentWillMount</span>') //<span class="attr">false</span></span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="Unicode-属性转义-p-…-和-P-…"><a href="#Unicode-属性转义-p-…-和-P-…" class="headerlink" title="Unicode 属性转义 \p{…} 和 \P{…}"></a>Unicode 属性转义 \p{…} 和 \P{…}</h4><p>在正则表达式模式中，您可以使用 <code>\d</code> 匹配任何数字，<code>\s</code> 匹配任何不为空格的字符，<code>\w</code> 匹配任何字母数字字符，依此类推<br>这个新功能将扩展此概念到引入 <code>\p{}</code> 匹配所有 Unicode 字符，否定为 <code>\P{}</code></p>
<p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">任何 unicode 字符都有一组属性。 例如，</span></span><code>Script</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>确定语言系列，<code>ASCII</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>是一个布尔值， 对于 ASCII 字符，值为 <code>true</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">，依此类推。 您可以将此属性放在花括号中，正则表达式将检查是否为真</span></span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/^\p&#123;ASCII&#125;+$/u.test(<span class="string">'abc'</span>)   <span class="comment">// true</span></span><br><span class="line">/^\p&#123;ASCII&#125;+$/u.test(<span class="string">'ABC@'</span>)  <span class="comment">// true</span></span><br><span class="line">/^\p&#123;ASCII&#125;+$/u.test(<span class="string">'ABC🙃'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p><code>ASCII_Hex_Digit</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>是另一个布尔属性，用于检查字符串是否仅包含有效的十六进制数字<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\p&#123;ASCII_Hex_Digit&#125;+$/u.test(<span class="string">'0123456789ABCDEF'</span>) <span class="comment">//true</span></span><br><span class="line">/^\p&#123;ASCII_Hex_Digit&#125;+$/u.test(<span class="string">'h'</span>)                <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">还有许多其他布尔属性，您只需通过在花括号中添加它们的名称来检查它们，包括 </span></span><code>Uppercase</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">, </span></span><code>Lowercase</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">, </span></span><code>White_Space</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">, </span></span><code>Alphabetic</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">, </span></span><code>Emoji</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>等<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/^\p&#123;Lowercase&#125;$/u.test(<span class="string">'h'</span>) <span class="comment">// true</span></span><br><span class="line">/^\p&#123;Uppercase&#125;$/u.test(<span class="string">'H'</span>) <span class="comment">// true</span></span><br><span class="line">/^\p&#123;Emoji&#125;+$/u.test(<span class="string">'H'</span>)   <span class="comment">// false</span></span><br><span class="line">/^\p&#123;Emoji&#125;+$/u.test(<span class="string">'🙃🙃'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">除了这些二进制属性之外，您还可以检查任何 unicode 字符属性以匹配特定值。在这个例子中，我检查字符串是用希腊语还是拉丁字母写的</span></span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\p&#123;Script=Greek&#125;+$/u.test(<span class="string">'ελληνικά'</span>) <span class="comment">// true</span></span><br><span class="line">/^\p&#123;Script=Latin&#125;+$/u.test(<span class="string">'hey'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<h4 id="命名捕获组（Named-capturing-groups）"><a href="#命名捕获组（Named-capturing-groups）" class="headerlink" title="命名捕获组（Named capturing groups）"></a>命名捕获组（Named capturing groups）</h4><p>JavaScript正则表达式可以返回匹配对象 - 类似于数组的值，包含匹配的字符串。例如，要以YYYY-MM-DD格式解析日期<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reDate = <span class="regexp">/([0-9]&#123;4&#125;)-([0-9]&#123;2&#125;)-([0-9]&#123;2&#125;)/</span>;</span><br><span class="line"><span class="keyword">const</span> match  = reDate.exec(<span class="string">'2018-04-30'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/115449/1541667684629-1aa986c0-6fbe-4e75-8c1a-9c1ae45ab34c.png" alt="屏幕快照 2018-11-08 17.00.56.png | center | 170x145"></p>
<p>它很难阅读，并且更改正则表达式也可能会更改匹配对象索引，ES2018允许在开始捕获括号后立即使用符号命名组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reDate = <span class="regexp">/(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/</span>;  </span><br><span class="line"><span class="keyword">const</span> match  = reDate.exec(<span class="string">'2018-04-30'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> year   = match.groups.year,  <span class="comment">// 2018</span></span><br><span class="line">      month  = match.groups.month, <span class="comment">// 04</span></span><br><span class="line">      day    = match.groups.day;   <span class="comment">// 30</span></span><br></pre></td></tr></table></figure></p>
<p>任何未匹配的命名组都将其属性设置为undefined</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-11-08</span><i class="fa fa-tag"></i><a class="tag" href="/tags/ES9/" title="ES9">ES9 </a></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2018/11/09/图片占位符/" title="图片占位符">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/11/07/ES8新特性/" title="ES8新特性">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>