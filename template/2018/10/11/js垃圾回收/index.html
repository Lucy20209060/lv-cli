<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Lucy"><title>js垃圾回收 · 长剑腥腥挂壁</title><meta name="description" content="1. 什么是垃圾回收许多脚本语言引擎，如V8引擎，对运行的应用程序实施动态的内存管理。引擎可以定期检查分配给应用程序的内存，确定哪些数据不再需要，并清除出来，以腾出内存空间。这个过程被称为垃圾回收。垃圾回收可以大幅简化程序的内存管理代码，降低程序员的负担，减少因长时间运转而带来的内存泄露问题。
JS"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/logo-2.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo-2.png" style="width:127px;"><h3 title=""><a href="/">长剑腥腥挂壁</a></h3></div></div><ul class="social-links"></ul></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/logo-2.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>js垃圾回收</a></h3></div><div class="post-content"><h3 id="1-什么是垃圾回收"><a href="#1-什么是垃圾回收" class="headerlink" title="1. 什么是垃圾回收"></a>1. <strong>什么是垃圾回收</strong></h3><p>许多脚本语言引擎，如V8引擎，对运行的应用程序实施动态的内存管理。<span data-type="background" style="background-color:#F5222D"><span data-type="color" style="color:#FFFFFF">引擎可以定期检查分配给应用程序的内存，确定哪些数据不再需要，并清除出来，以腾出内存空间。这个过程被称为垃圾回收。</span></span>垃圾回收可以大幅简化程序的内存管理代码，降低程序员的负担，减少因长时间运转而带来的内存泄露问题。</p>
<p>JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。</p>
<p>C#、Java、JavaScript有自动垃圾回收机制，但c++和c就没有垃圾回收机制，也许是因为垃圾回收机制必须由一种平台来实现。在JS中，JS的执行环境会负责管理代码执行过程中使用的内存。</p>
<p><span data-type="color" style="color:rgb(0, 0, 0)"><span data-type="background" style="background-color:rgb(255, 255, 255)">事实上，垃圾回收是一个复杂的过程。Google V8的垃圾回收方法能够自动完成垃圾回收，大大减轻了应用开发者的负担，能够让他们集中精力于更重要的事情上。尽管目前V8的垃圾回收引擎并不完美，仍存在一些性能问题而且偶尔会出现奇怪的现象</span></span></p>
<h3 id="2-垃圾回收的必要性"><a href="#2-垃圾回收的必要性" class="headerlink" title="2. 垃圾回收的必要性"></a>2. <strong>垃圾回收的必要性</strong></h3><p>由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。</p>
<h3 id="3-垃圾回收原理浅析"><a href="#3-垃圾回收原理浅析" class="headerlink" title="3. 垃圾回收原理浅析"></a><strong>3. 垃圾回收原理浅析</strong></h3><p>现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数。</p>
<p><strong>1、标记清除</strong><br>这是javascript中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。</p>
<p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</p>
<p><strong>2、引用计数</strong><br>另一种不太常见的垃圾回收策略是引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-10-11</span><i class="fa fa-tag"></i><a class="tag" href="/tags/js/" title="js">js </a><a class="tag" href="/tags/垃圾回收/" title="垃圾回收">垃圾回收 </a></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2018/10/12/数组去重/" title="数组去重">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/10/10/自定义延时函数/" title="自定义延时函数">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>